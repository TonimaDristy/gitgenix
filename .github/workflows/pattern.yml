name: Generate GitHub Art

on:
  workflow_dispatch:

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Run GitGenix contribution generator
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'EOF'
          import json
          import re
          import subprocess
          from pathlib import Path
          from datetime import datetime

          def fix_json(raw_text):
              """Fix broken JSON and parse stringified objects"""
              cleaned = re.sub(r',(\s*[\]}])', r'\1', raw_text)
              cleaned = cleaned.replace('\n', '').replace('\t', '')
              try:
                  data = json.loads(cleaned)
              except json.JSONDecodeError as e:
                  print(f"Still invalid JSON: {e}")
                  raise

              def parse_strings(obj):
                  if isinstance(obj, dict):
                      return {k: parse_strings(v) for k, v in obj.items()}
                  elif isinstance(obj, list):
                      return [parse_strings(v) for v in obj]
                  elif isinstance(obj, str):
                      obj_strip = obj.strip()
                      if obj_strip.startswith('{') or obj_strip.startswith('['):
                          try:
                              return parse_strings(json.loads(obj_strip))
                          except:
                              return obj
                      return obj
                  else:
                      return obj

              return parse_strings(data)

          # Load and fix pattern.json
          path = Path("pattern.json")
          raw = path.read_text(encoding="utf-8")
          data = fix_json(raw)

          metadata = data.get("metadata", {})
          username = metadata.get("username", "unknown")
          branch = metadata.get("branch", "main")

          # Loop through all cells and create commits
          graphs = data.get("graphs", {})
          for year, content in graphs.items():
              cells = content.get("cells", [])
              for cell in cells:
                  date = cell.get("date")
                  intensity = cell.get("intensity", 1)
                  isOutOfRange = cell.get("isOutOfRange", False)

                  if isOutOfRange:
                      continue  # Skip out-of-range dates

                  # Create dummy file for commit
                  filename = f"contrib_{date}.txt"
                  Path(filename).write_text(f"Contribution intensity: {intensity}")

                  # Create git commit with specific date
                  commit_date = datetime.fromisoformat(date.replace("Z", "+00:00"))
                  env = {
                      "GIT_AUTHOR_DATE": commit_date.isoformat(),
                      "GIT_COMMITTER_DATE": commit_date.isoformat()
                  }
                  subprocess.run(["git", "add", filename], check=True)
                  subprocess.run(
                      ["git", "commit", "-m", f"GitGenix contribution {date}"],
                      check=True,
                      env={**env, **dict(**subprocess.os.environ)}
                  )

          # Push commits to the specified branch
          subprocess.run(["git", "push", "origin", branch], check=True)
          print(f"Finished GitGenix contributions for {username} on branch {branch}")
          EOF
